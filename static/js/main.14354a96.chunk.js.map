{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["socket","io","process","App","randomUserName","Math","round","random","useState","title","history","msg","user","users","rooms","setRooms","activeRoom","setActiveRoom","otherUsers","setOtherUsers","error","setError","inputMsg","useRef","inputUser","inputUserTo","txtChat","leaveRoom","console","log","emit","room","current","value","useEffect","userMe","otherRoomUsers","filter","name","unshift","socketId","updateOtherUserList","on","forEach","listenerName","hasListeners","removeEventListener","objMsg","roomsCopy","roomFound","find","currentRoom","push","addMessageToHistory","scrollTop","scrollHeight","length","updateUserListOfRoom","username","removeUserFromRoom","className","map","key","onClick","e","switchRoom","autoComplete","placeholder","readOnly","ref","msgFormatted","direct","userToName","formatMessage","join","type","id","defaultValue","onChange","otherUser","userToId","userToIndex","selectedIndex","options","text","msgObj","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.14354a96.chunk.js","sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport './App.css';\nimport io from 'socket.io-client';\n\n// connect to socket IO port depending on environment\nlet apiBaseUrl = process.env.REACT_APP_API_BASEURL\n// let socketIoPort = process.env.NODE_ENV === \"production\" ? undefined : ':8000'\nlet socket = io(apiBaseUrl);\n\nfunction App() {\n\n  const randomUserName = \"Rob-\" + Math.round((Math.random()*100))\n\n  // state: rooms with histories\n  let [ rooms, setRooms ] = useState([\n    {\n      title: 'Room 1',\n      history: [\n        { msg: 'Hello Irina', user: 'Rob' }, \n        { msg: 'Hey Rob', user: 'Irina' } ],\n      users: [ 'Rob', 'Irina' ]\n    },\n    {\n      title: 'Room 2',\n      history: [ { msg: 'Hello to issue channel', user: 'Admin' } ],\n      users: [ 'Admin' ]\n    }\n  ]);\n  let [ activeRoom, setActiveRoom ] = useState();\n  let [ otherUsers, setOtherUsers ] = useState()\n  let [ error, setError ] = useState('');\n\n  // define refs to grab values of input fields easily\n  let inputMsg = useRef();\n  let inputUser = useRef();\n  let inputUserTo = useRef();\n  let txtChat = useRef();\n\n  // switch room in state\n  const switchRoom = (room) => {\n    let user = inputUser.current.value;\n\n    // do not switch to a room we are already in\n    if(activeRoom && room.title == activeRoom.title) {\n      return\n    }\n\n    // switch room\n      // leave current room\n      // join new room\n      // update user list\n    if (user) {\n\n      if(activeRoom) {\n        leaveRoom()\n      }\n\n      setActiveRoom(room);\n      console.log(`Switched room to ${room.title}`);\n\n      // join room in backend too\n      socket.emit('joinRoom', { room: room.title, user });\n      setError('');\n    } \n    else {\n      console.log('Please provide a user name before joining');\n      setError('Please provide a user name before joining');\n    }\n  };\n\n  // send message to currently active room\n  const sendMessage = () => {\n    let msg = inputMsg.current.value;\n    let user = inputUser.current.value;\n\n    // get user to information\n    let userToId = inputUserTo.current.value\n    let userToIndex = inputUserTo.current.selectedIndex\n    let userToName = inputUserTo.current.options[userToIndex].text\n\n    if (!activeRoom) {\n      console.log('Please join a room first - and state a username');\n      setError('Please join a room first - and state a username');\n    } \n    else if (!(msg && user)) {\n      console.log('Please provide username & message');\n      setError('Please provide username & message');\n    } \n    else {\n      let msgObj = { msg, user, room: activeRoom.title }\n\n      // direct message? append user-to information\n      if(userToId) {\n        msgObj = { ...msgObj, userToId, userToName }\n      }\n      \n      console.log(`Sending ${userToId ? \"(private)\" : \"\"}: `, msgObj)\n      \n      socket.emit('message', msgObj);\n      setError('');\n      \n      inputMsg.current.value = \"\"\n    }\n  };\n\n  // add received message to chat history of given room\n  const addMessageToHistory = (objMsg) => {\n\n    // update chat history by creating a copy of state, updating it & re-assign it\n    let roomsCopy = [ ...rooms ];\n\n    // find room message was sent to\n    let roomFound = roomsCopy.find((currentRoom) => currentRoom.title == objMsg.room);\n\n    // add message to chat history array of given room\n    if (roomFound) {\n      roomFound.history.push(objMsg);\n      setRooms(roomsCopy);\n    }\n  };\n\n  const formatMessage = (objMsg) => {\n    let msgFormatted = objMsg.user // start message with sender username\n\n    // format direct messages with info who sent message to whom\n    if(objMsg.direct) {\n      let userMe = inputUser.current.value\n      msgFormatted += \" (private to \" +\n        (userMe === objMsg.userToName ? \"you\" : objMsg.userToName) + \")\"\n    }\n    msgFormatted += \": \" + objMsg.msg\n    return msgFormatted\n  }\n\n  const updateOtherUserList = () => {\n    if(!activeRoom) return\n\n    let userMe = inputUser.current.value\n\n    let otherRoomUsers = activeRoom.users.filter(user => user.name != userMe)\n    // append message to everyone\n    otherRoomUsers.unshift({name: \"To everyone\", socketId: \"\"})\n    console.log(\"Other users: \", otherRoomUsers)\n    setOtherUsers(otherRoomUsers)\n  }\n\n  // whenever users join or leave => update the user list in room\n  const updateUserListOfRoom = (room, users) => {\n    let roomsCopy = [...rooms]\n    let roomFound = roomsCopy.find((currentRoom) => currentRoom.title == room);\n    if(roomFound) {\n      roomFound.users = users\n    }\n    console.log(\"Updated users:\", roomFound.users)\n    setRooms(roomsCopy)\n  }\n\n  const removeUserFromRoom = (room, username) => {\n    let roomsCopy = [...rooms]\n    let roomFound = roomsCopy.find((currentRoom) => currentRoom.title == room);\n    if(roomFound) {\n      roomFound.users = roomFound.users.filter(user => user.name != username)\n    }\n    console.log(\"Updated users after removal:\", roomFound.users)\n    setRooms(roomsCopy)\n  }\n\n  const leaveRoom = () => {\n    if(!activeRoom) return\n    console.log(\"Leaving room: \", activeRoom.title)\n    socket.emit(\"leaveRoom\", { room: activeRoom.title, user: inputUser.current.value})\n    setActiveRoom()\n  }\n\n  const clearRoom = () => {\n    if(!activeRoom) return\n    console.log(\"Clearing room: \", activeRoom.title)\n    socket.emit(\"clearRoom\", activeRoom.title)\n  }\n\n  useEffect(() => { \n    console.log(\"Rooms changed: \", rooms)\n    // update the direct message select box\n    updateOtherUserList()\n  }, [rooms])\n\n  // define socket.io event listener\n  // AFTER first render (\"componentDidMount\")\n  useEffect(() => {\n\n    // receive rooms\n    socket.on(\"getRooms\", (rooms) => {\n      // console.log(\"Rooms:\", rooms)\n      setRooms(rooms)\n    })\n\n    // request rooms\n    socket.emit(\"getRooms\")\n\n    return () => {\n      leaveRoom()\n    }\n\n  }, []);\n\n  // after a room was chosen => listen for messages in this room\n  useEffect(() => {\n\n    console.log(\"Active Room changed: \", activeRoom)\n\n    // clear message event listeners & recreate them\n    let arrListeners = ['message', 'userList', 'removeUser']\n    arrListeners.forEach(listenerName => {\n      if(socket.hasListeners(listenerName)) {\n          socket.removeEventListener(listenerName)\n      }\n    })\n\n    // on message receipt: add to state\n    socket.on('message', (objMsg) => {\n      console.log('Yay! Message received: ', objMsg);\n\n      addMessageToHistory(objMsg);\n      // scroll to last message (end of textarea)\n      txtChat.current.scrollTop = txtChat.current.scrollHeight;\n    });\n\n    socket.on(\"userList\", ({room, users}) => { \n      console.log(\"Users updated: \", room, users)\n\n      // if user list is empty => room was cleared => leave room here!\n      if(users && users.length === 0) {\n        leaveRoom()\n      }\n      else {\n        updateUserListOfRoom(room, users)\n      }\n    })\n\n    socket.on(\"removeUser\", ({room, user}) => {\n      console.log(\"removeUser: \", room, user)\n      removeUserFromRoom(room, user)\n    })\n\n  }, [activeRoom])\n  \n\n  // UI rendering\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <p>Chat-App</p>\n      </header>\n      <main>\n        <div className=\"chat\">\n          <div className=\"chat-rooms\">\n            <div className=\"chat-rooms-title\">Rooms</div>\n            <ul>\n              {rooms.map((room) => (\n                <li className={activeRoom && room.title == activeRoom.title ? \"active-room-li\" : \"\"} key={room.title} onClick={(e) => switchRoom(room)}>\n                  {room.title}\n                </li>\n              ))}\n            </ul>\n            {activeRoom && (\n            <div>\n              <button onClick={leaveRoom} >{`Leave ${activeRoom.title}`}</button>\n            </div>\n            )}\n          </div>\n          <div className=\"chat-history\">\n            <div className=\"active-room-title\">{activeRoom ? activeRoom.title : '(no room active)'}</div>\n            <textarea\n              autoComplete=\"off\"\n              placeholder=\"Chat messages...\"\n              readOnly\n              ref={txtChat}\n              value={\n                activeRoom ?\n                activeRoom.history.map((objMsg) => formatMessage(objMsg)).join('\\n')\n                : \"\"\n              }\n            />\n            <div className=\"chat-message\">\n              <input placeholder=\"Username...\" \n                autoComplete=\"off\" \n                type=\"text\" \n                id=\"user\" defaultValue={randomUserName}\n                ref={inputUser} />\n              {activeRoom && (\n                <>\n                <select ref={inputUserTo} onChange={(e) => (e)}>\n                  {otherUsers && otherUsers.map(otherUser => (\n                    <option value={otherUser.socketId} >{otherUser.name}</option>\n                  ))}\n                </select>\n                <input\n                  placeholder=\"Write your message here...\"\n                  autoComplete=\"off\"\n                  type=\"text\"\n                  id=\"message\"\n                  ref={inputMsg}\n                />\n                <button onClick={sendMessage}>Send</button>\n                </>\n              )}\n              </div>\n          </div>\n          <div className=\"chat-users\">\n            <div className=\"chat-users-title\">Users</div>\n            <ul>\n              {activeRoom && activeRoom.users.map((user) => (\n                <li key={user.name}>{user.name}</li>\n              ))}\n            </ul>\n            {activeRoom && (\n            <div className=\"chat-users-kickout\">\n              <button onClick={clearRoom} >Kick out all users</button>\n            </div>\n            )}\n          </div>\n        </div>\n      </main>\n      <div className=\"errors\">{error}</div>\n      <footer>&copy; My Chat Copyright</footer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}